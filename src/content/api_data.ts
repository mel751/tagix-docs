// Auto-generated by scripts/api-docs/generate-api-docs.ts — 2/11/2026, 10:18:28 PM
export interface ApiItem {
  name: string;
  kind: string;
  description: string;
}

export const API_DOCS: ApiItem[] = [
  {
    name: "absurd",
    kind: "function",
    description: "",
  },
  {
    name: "AbsurdError",
    kind: "const",
    description:
      "Thrown when an absurd/unreachable condition is met.\n\n@remarks\nThis should never be called and indicates a logical error in exhaustive pattern matching.",
  },
  {
    name: "AbsurdError",
    kind: "type",
    description: "",
  },
  {
    name: "Action",
    kind: "interface",
    description: "Synchronous action definition.",
  },
  {
    name: "ACTION_TYPE_PREFIX",
    kind: "const",
    description: "Prefix applied to all action types internally.",
  },
  {
    name: "ActionDescriptor",
    kind: "interface",
    description: "",
  },
  {
    name: "ActionNotFoundError",
    kind: "const",
    description: "Thrown when dispatching an action type that has not been registered.",
  },
  {
    name: "ActionNotFoundError",
    kind: "type",
    description: "",
  },
  {
    name: "all",
    kind: "function",
    description: "",
  },
  {
    name: "and",
    kind: "function",
    description: "",
  },
  {
    name: "any",
    kind: "function",
    description: "",
  },
  {
    name: "asVariant",
    kind: "function",
    description:
      "Narrows the state to a specific variant if it matches the given tag.\nReturns undefined if the state is not the specified variant.\n\n@returns\nThe narrowed state or undefined.",
  },
  {
    name: "AsyncAction",
    kind: "interface",
    description: "Asynchronous action with side effects.",
  },
  {
    name: "AsyncActionDescriptor",
    kind: "interface",
    description: "",
  },
  {
    name: "collect",
    kind: "function",
    description: "",
  },
  {
    name: "combineSelectors",
    kind: "function",
    description:
      "Combines multiple selectors into a single selector returning a tuple.\n\n@returns\nA selector that returns a tuple of results.\n\n@remarks\nOverloaded for 2 or 3 selectors.",
  },
  {
    name: "constant",
    kind: "function",
    description: "",
  },
  {
    name: "constFalse",
    kind: "const",
    description: "",
  },
  {
    name: "constNull",
    kind: "const",
    description: "",
  },
  {
    name: "constTrue",
    kind: "const",
    description: "",
  },
  {
    name: "constUndefined",
    kind: "const",
    description: "",
  },
  {
    name: "constVoid",
    kind: "const",
    description: "",
  },
  {
    name: "ContextConfig",
    kind: "interface",
    description: "Configuration options for creating a TagixContext.",
  },
  {
    name: "ContextDisposedError",
    kind: "const",
    description:
      "Thrown when attempting to perform operations on a disposed context.\n\n@remarks\nContexts should be properly disposed and not reused after disposal.",
  },
  {
    name: "ContextDisposedError",
    kind: "type",
    description: "",
  },
  {
    name: "ContextId",
    kind: "type",
    description: "Unique identifier for context entries and subcontexts.",
  },
  {
    name: "createAction",
    kind: "function",
    description:
      'Creates a synchronous action builder.\n\n@returns\nAction builder with chainable methods.\n\n@example\n````ts\nconst increment = createAction("Increment")\n  .withPayload({ amount: 1 })\n  .withState((s, p) => ({ count: s.count + p.amount }));\n````',
  },
  {
    name: "createActionGroup",
    kind: "function",
    description:
      'Creates an action group with a namespace prefix for all actions.\n\n@returns\nA new action group with prefixed action types.\n\n@remarks\nEach action\'s type is prefixed with ``tagix/action/{namespace}/`` to avoid naming collisions.\nOriginal actions are not mutated - new cloned actions are returned.\n\n- Trailing slashes are handled automatically (``"User/"`` => ``"User/Login"``)\n- Actions can be dispatched using the group: ``store.dispatch(UserActions.login, payload)``\n- Or by string: ``store.dispatch("User/Login", payload)``\n\n@example\n````ts\nconst login = createAction("Login").withState((_, { username }) =>\n  UserState.LoggedIn({ name: username, email: "" })\n);\n\nconst UserActions = createActionGroup("User", { login });\n// UserActions.login.type === "tagix/action/User/Login"\n````',
  },
  {
    name: "createAsyncAction",
    kind: "function",
    description:
      'Creates an asynchronous action builder with side effects.\n\n@returns\nAsync action builder with chainable methods.\n\n@remarks\nBuilder pattern: call ``state``, ``effect``, ``onSuccess``, then ``onError`` to complete.\n\n@example\n````ts\nconst fetchUser = createAsyncAction<{ id: string }, UserState, User>("FetchUser")\n  .state(s => ({ ...s, loading: true }))\n  .effect(p => api.getUser(p.id))\n  .onSuccess((s, user) => ({ ...s, user, loading: false }))\n  .onError((s, err) => ({ ...s, error: err, loading: false }));\n````',
  },
  {
    name: "createContext",
    kind: "function",
    description: "Creates a new TagixContext instance.\n\n@returns\nA new TagixContext instance.",
  },
  {
    name: "createErrorPayload",
    kind: "function",
    description:
      "Creates an error payload with the corresponding error code.\n\n@returns\nThe payload with the error code added.",
  },
  {
    name: "createLoggerMiddleware",
    kind: "function",
    description:
      'Creates a middleware that logs actions and state changes to the console.\n\n@returns\nA middleware function.\n\n@remarks\nSupports collapsed groups, timestamps, duration tracking, and custom transformers.\n\n@example\n````ts\nconst logger = createLoggerMiddleware({\n  collapsed: true,\n  duration: true,\n  predicate: (action) => action.type.includes("User")\n});\n````',
  },
  {
    name: "createSelector",
    kind: "function",
    description:
      "Build a selector function that reads from state every time you call it.\n\n@returns\nA function you can call to get the current value.\n\n@example\n````ts\nconst getUserName = createSelector(context, (state) => state.user?.name);\nconst name = getUserName();\n````",
  },
  {
    name: "createStore",
    kind: "function",
    description:
      'Creates a new TagixStore instance.\n\n@returns\nA new TagixStore instance.\n\n@example\n````ts\nconst store = createStore(\n  CounterState.Value({ count: 0 }),\n  CounterState,\n  { name: "Counter" }\n);\n````',
  },
  {
    name: "deepEqual",
    kind: "function",
    description: "",
  },
  {
    name: "DEFAULT_CONFIG",
    kind: "const",
    description:
      "Default configuration values for TagixStore.\n\n@remarks\nUsed when no configuration is provided to ``createStore``.",
  },
  {
    name: "DerivedStore",
    kind: "class",
    description:
      "A read-only reactive store whose state is derived from one or more source\nTagixStore instances. The derived value is recomputed whenever any\nsource store's state changes, and subscribers are only notified when the\nderived value structurally changes (controlled via ``deepEqual`` or a custom\nequality function).\n\n@remarks\n``DerivedStore`` is intentionally **not** a ``TagixStore``. It is read-only —\nthere is no ``dispatch``, ``register``, or ``setState``. This prevents misuse and\nkeeps the data flow unidirectional: source stores own the state, and derived\nstores passively compute and propagate.\n\n@example\n````ts\nconst cartTotal = deriveStore(\n  [cartStore, discountStore],\n  ([cart, discount]) => ({\n    total: cart.items.reduce((sum, i) => sum + i.price, 0) * (1 - discount.rate),\n  })\n);\n\ncartTotal.subscribe((derived) => console.log(derived.total));\n````",
  },
  {
    name: "DerivedStoreConfig",
    kind: "interface",
    description: "Configuration options for a derived store.",
  },
  {
    name: "deriveStore",
    kind: "function",
    description: "Implementation signature - not exposed as public API.",
  },
  {
    name: "DevToolsConfig",
    kind: "interface",
    description: "",
  },
  {
    name: "dual",
    kind: "function",
    description: "",
  },
  {
    name: "Either",
    kind: "type",
    description: "",
  },
  {
    name: "ensureState",
    kind: "function",
    description:
      "Ensures store state matches a specific tag, throwing if it doesn't.\n\n@returns\nThe narrowed state.\n\n@throws\nIf state tag doesn't match.",
  },
  {
    name: "ERROR_CATEGORIES",
    kind: "const",
    description:
      "Error categories grouping related error codes.\n\n@remarks\nUsed for error analytics and recovery strategies.",
  },
  {
    name: "ERROR_CODES",
    kind: "const",
    description:
      "Numeric error codes for each error type.\n\n@remarks\nUsed for error categorization and analytics.",
  },
  {
    name: "ERROR_NAMES",
    kind: "const",
    description:
      "Error name constants for Tagix error types.\n\n@remarks\nUsed internally for error identification and categorization.",
  },
  {
    name: "ErrorCategory",
    kind: "type",
    description: "Union type of all error category names.",
  },
  {
    name: "ErrorCode",
    kind: "type",
    description: "Union type of all error codes.",
  },
  {
    name: "ErrorName",
    kind: "type",
    description: "Union type of all error names.",
  },
  {
    name: "ErrorsConfig",
    kind: "interface",
    description: "",
  },
  {
    name: "exhaust",
    kind: "function",
    description:
      "Exhaustive pattern matching on state, requiring handlers for all tags.\n\n@returns\nThe handler result for the matching tag.\n\n@throws\nIf no handler exists for the state tag.\n\n@remarks\nEnforces compile-time exhaustiveness via type system.",
  },
  {
    name: "expect",
    kind: "function",
    description: "",
  },
  {
    name: "fail",
    kind: "function",
    description: "",
  },
  {
    name: "filter",
    kind: "function",
    description: "",
  },
  {
    name: "flatMap",
    kind: "function",
    description: "",
  },
  {
    name: "flow",
    kind: "function",
    description: "",
  },
  {
    name: "fork",
    kind: "function",
    description:
      'Creates an isolated fork of a store with its own state copy.\n\n@returns\nA new store with an independent copy of the source state.\n\n@remarks\nThe forked store:\n- Has its own isolated state (changes don\'t affect the source)\n- Starts with the same state as the source at fork time\n- Has all registered actions from the source copied over\n- Uses ``strict: false`` to allow state transitions that may differ from source\n- Has independent error history\n\n@example\n````ts\nconst mainStore = createStore(UserState.LoggedOut({}), UserState);\nmainStore.registerGroup(UserActions);\n\nconst forkedStore = fork(mainStore);\nforkedStore.dispatch(UserActions.login, { username: "temp" });\n\nconsole.log(mainStore.stateValue._tag); // "LoggedOut"\nconsole.log(forkedStore.stateValue._tag); // "LoggedIn"\n````',
  },
  {
    name: "fromNullable",
    kind: "function",
    description: "",
  },
  {
    name: "fromPayload",
    kind: "function",
    description:
      "Creates a function that extracts a required payload, throwing if missing.\n\n@returns\nA function that throws ``RequiredPayloadError`` if payload is null/undefined.",
  },
  {
    name: "getErrorCategory",
    kind: "function",
    description:
      "Gets the category for a given error code.\n\n@returns\nThe error category, or undefined if not found.",
  },
  {
    name: "getErrorCode",
    kind: "function",
    description: "",
  },
  {
    name: "getErrorInfo",
    kind: "function",
    description:
      "Extracts structured error information from an unknown error.\n\n@returns\nTagixErrorObject if the error is a Tagix error, null otherwise.",
  },
  {
    name: "getOrDefault",
    kind: "function",
    description:
      "Creates a function that returns a default value if input is undefined.\n\n@returns\nA function that returns the input value or the default.",
  },
  {
    name: "getOrElse",
    kind: "function",
    description: "",
  },
  {
    name: "getOrNull",
    kind: "function",
    description: "",
  },
  {
    name: "getOrThrow",
    kind: "function",
    description: "",
  },
  {
    name: "getOrUndefined",
    kind: "function",
    description: "",
  },
  {
    name: "getProperty",
    kind: "function",
    description:
      "Type-safe property accessor for tagged union states.\nReturns undefined if the property doesn't exist on the current variant.\n\n@returns\nThe property value or undefined.",
  },
  {
    name: "getState",
    kind: "function",
    description:
      "Gets state from a store if it matches the specified tag.\n\n@returns\nSome(state) if tag matches, None otherwise.",
  },
  {
    name: "GetState",
    kind: "type",
    description: "",
  },
  {
    name: "getStateProp",
    kind: "function",
    description:
      'Read a specific property from a state object using its variant tag.\n\n@returns\nA getter function for state properties.\n\n@example\n````ts\nconst state = store.getCurrent();\n\n// Get a single property\nconst name = getStateProp(state)("LoggedIn", "name");\n\n// Or get the whole props object for a tag\nconst userProps = getStateProp(state)("LoggedIn");\nif (userProps) {\n  console.log(userProps.name);\n  console.log(userProps.email);\n}\n````',
  },
  {
    name: "getStatePropRaw",
    kind: "function",
    description: "Internal helpers for state property access.",
  },
  {
    name: "getTag",
    kind: "function",
    description: "Gets the tag from a state value.\n\n@returns\nThe state tag.",
  },
  {
    name: "getValue",
    kind: "function",
    description:
      'Safely gets a property value from a tagged union state.\nReturns the value if present, otherwise returns the default value.\n\n@returns\nThe property value or the default.\n\n@example\n````ts\n// In an action handler, safely access \'value\' which may not exist on all variants:\nconst increment = createAction<{ amount: number }, CounterState>("Increment")\n  .withPayload({ amount: 1 })\n  .withState((s, p) => ({\n    ...s,\n    value: getValue(s, "value", 0) + p.amount,\n  }));\n````',
  },
  {
    name: "hasProperty",
    kind: "function",
    description:
      "Type guard that checks if an object has a specific property.\n\n@returns\nTrue if the object has the property, narrowing the type.",
  },
  {
    name: "hasTag",
    kind: "function",
    description:
      "Checks if a state value has a specific tag.\n\n@returns\nTrue if state tag matches.",
  },
  {
    name: "identity",
    kind: "function",
    description: "",
  },
  {
    name: "InvalidActionError",
    kind: "const",
    description:
      "Thrown when an action object is malformed or missing required properties.\n\n@remarks\nCatches issues like invalid effect function, missing state/onSuccess/onError handlers.",
  },
  {
    name: "InvalidActionError",
    kind: "type",
    description: "",
  },
  {
    name: "InvalidPayloadError",
    kind: "const",
    description:
      "Thrown when payload validation fails.\n\n@remarks\nUse ``validatePayload`` guard to trigger this error.",
  },
  {
    name: "InvalidPayloadError",
    kind: "type",
    description: "",
  },
  {
    name: "isAction",
    kind: "function",
    description:
      "Type guard to check if a value is a Tagix Action.\n\n@returns\nTrue if value is an Action.",
  },
  {
    name: "isArray",
    kind: "function",
    description: "",
  },
  {
    name: "isArrayPayload",
    kind: "const",
    description: "Type guard for array payloads.",
  },
  {
    name: "isAsyncAction",
    kind: "function",
    description:
      "Type guard to check if a value is an AsyncAction.\n\n@returns\nTrue if value is an AsyncAction with valid structure.",
  },
  {
    name: "isBoolean",
    kind: "function",
    description: "",
  },
  {
    name: "isBooleanPayload",
    kind: "const",
    description: "Type guard for boolean payloads.",
  },
  {
    name: "isDate",
    kind: "function",
    description: "",
  },
  {
    name: "isEither",
    kind: "function",
    description: "",
  },
  {
    name: "isEmptyArray",
    kind: "function",
    description: "",
  },
  {
    name: "isEmptyObject",
    kind: "function",
    description: "",
  },
  {
    name: "isEmptyString",
    kind: "function",
    description: "",
  },
  {
    name: "isError",
    kind: "function",
    description: "",
  },
  {
    name: "isFiniteNumber",
    kind: "function",
    description: "",
  },
  {
    name: "isFunction",
    kind: "function",
    description: "",
  },
  {
    name: "isInState",
    kind: "function",
    description:
      "Checks if store state has a specific tag.\n\n@returns\nTrue if state tag matches.",
  },
  {
    name: "isInteger",
    kind: "function",
    description: "",
  },
  {
    name: "isLeft",
    kind: "function",
    description: "",
  },
  {
    name: "isNegativeNumber",
    kind: "function",
    description: "",
  },
  {
    name: "isNone",
    kind: "function",
    description: "",
  },
  {
    name: "isNonEmptyArray",
    kind: "function",
    description: "",
  },
  {
    name: "isNonEmptyString",
    kind: "function",
    description: "",
  },
  {
    name: "isNotNull",
    kind: "function",
    description: "",
  },
  {
    name: "isNotNullish",
    kind: "function",
    description: "",
  },
  {
    name: "isNotUndefined",
    kind: "function",
    description: "",
  },
  {
    name: "isNull",
    kind: "function",
    description: "",
  },
  {
    name: "isNullish",
    kind: "function",
    description: "",
  },
  {
    name: "isNumber",
    kind: "function",
    description: "",
  },
  {
    name: "isNumberPayload",
    kind: "const",
    description: "Type guard for number payloads.",
  },
  {
    name: "isOption",
    kind: "function",
    description: "",
  },
  {
    name: "isPlainObject",
    kind: "function",
    description: "",
  },
  {
    name: "isPlainObjectPayload",
    kind: "const",
    description: "Type guard for plain object payloads (not arrays, dates, etc.).",
  },
  {
    name: "isPositiveNumber",
    kind: "function",
    description: "",
  },
  {
    name: "isPromise",
    kind: "function",
    description: "",
  },
  {
    name: "isRecord",
    kind: "function",
    description: "",
  },
  {
    name: "isRecordPayload",
    kind: "const",
    description: "Type guard for record/object payloads.",
  },
  {
    name: "isRecoverableError",
    kind: "function",
    description:
      "Checks if an error code represents a recoverable error.\n\n@returns\nTrue if the error is recoverable (STATE, ACTION, or PAYLOAD category).",
  },
  {
    name: "isRegExp",
    kind: "function",
    description: "",
  },
  {
    name: "isRight",
    kind: "function",
    description: "",
  },
  {
    name: "isSafeInteger",
    kind: "function",
    description: "",
  },
  {
    name: "isSome",
    kind: "function",
    description: "",
  },
  {
    name: "isString",
    kind: "function",
    description: "",
  },
  {
    name: "isStringPayload",
    kind: "const",
    description: "Type guard for string payloads.",
  },
  {
    name: "isTagged",
    kind: "function",
    description: "",
  },
  {
    name: "isTaggedError",
    kind: "function",
    description: "",
  },
  {
    name: "isTagixError",
    kind: "function",
    description:
      "Type guard to check if an error is a Tagix error.\n\n@returns\nTrue if the error has the Tagix error structure.",
  },
  {
    name: "isUndefined",
    kind: "function",
    description: "",
  },
  {
    name: "LazyArg",
    kind: "interface",
    description: "",
  },
  {
    name: "left",
    kind: "function",
    description: "",
  },
  {
    name: "Left",
    kind: "interface",
    description: "",
  },
  {
    name: "map",
    kind: "function",
    description: "",
  },
  {
    name: "mapLeft",
    kind: "function",
    description: "",
  },
  {
    name: "match",
    kind: "function",
    description: "",
  },
  {
    name: "MatchCases",
    kind: "type",
    description: "",
  },
  {
    name: "matchState",
    kind: "function",
    description:
      "Pattern matches on state, executing the handler for the matching tag.\n\n@returns\nThe handler result, or undefined if no handler exists for the tag.\n\n@remarks\nNon-exhaustive: missing tags return undefined.",
  },
  {
    name: "matchTag",
    kind: "function",
    description: "",
  },
  {
    name: "memoize",
    kind: "function",
    description:
      "Memoizes a selector function using deep equality comparison.\n\n@returns\nA memoized version that returns cached result for equal input values.\n\n@remarks\nUses deep equality for comparison. Cache invalidates when input values change structurally.",
  },
  {
    name: "Middleware",
    kind: "type",
    description:
      "Middleware function that wraps action dispatch.\n\n@remarks\nThe returned function should return ``true`` (or void) to proceed with action execution, or ``false`` to block.",
  },
  {
    name: "MiddlewareContext",
    kind: "interface",
    description: "Context object passed to middleware functions.",
  },
  {
    name: "MissingHandlerError",
    kind: "const",
    description: "Thrown when an action handler is not registered for a dispatched action.",
  },
  {
    name: "MissingHandlerError",
    kind: "type",
    description: "",
  },
  {
    name: "none",
    kind: "function",
    description: "",
  },
  {
    name: "None",
    kind: "interface",
    description: "",
  },
  {
    name: "nonEmptyArray",
    kind: "function",
    description:
      "Type guard for non-empty arrays.\n\n@returns\nTrue if value is a non-empty array.",
  },
  {
    name: "NonExhaustiveMatchError",
    kind: "const",
    description:
      "Thrown when pattern matching is non-exhaustive.\n\n@remarks\nUse ``exhaust`` function to ensure all state tags are handled.",
  },
  {
    name: "NonExhaustiveMatchError",
    kind: "type",
    description: "",
  },
  {
    name: "not",
    kind: "function",
    description: "",
  },
  {
    name: "notEmptyString",
    kind: "function",
    description:
      "Type guard for non-empty strings.\n\n@returns\nTrue if value is a non-empty string.",
  },
  {
    name: "ok",
    kind: "function",
    description: "",
  },
  {
    name: "on",
    kind: "function",
    description:
      "Creates a function that executes only when state matches a specific tag.\n\n@returns\nA function that returns undefined if tag doesn't match, otherwise executes the handler.",
  },
  {
    name: "Option",
    kind: "type",
    description: "",
  },
  {
    name: "OptionNoneError",
    kind: "const",
    description:
      "Thrown when attempting to unwrap a None value.\n\n@remarks\nUse ``unwrap`` or ``unwrapOr`` to safely access Option values.",
  },
  {
    name: "OptionNoneError",
    kind: "type",
    description: "",
  },
  {
    name: "or",
    kind: "function",
    description: "",
  },
  {
    name: "orElse",
    kind: "function",
    description: "",
  },
  {
    name: "partition",
    kind: "function",
    description: "",
  },
  {
    name: "patch",
    kind: "function",
    description:
      "Creates an immutable patching function for objects.\n\n@returns\nA chainable patching function with a ``value`` property.\n\n@remarks\nEach call returns a new object, enabling immutable updates.\n\n@example\n````ts\nconst patcher = patch({ a: 1, b: 2 });\nconst result = patcher({ b: 3 })({ c: 4 }).value;\n// result = { a: 1, b: 3, c: 4 }\n````",
  },
  {
    name: "PayloadOf",
    kind: "type",
    description: "Extracts the payload type from an Action or ActionCreator.",
  },
  {
    name: "PayloadValidationError",
    kind: "const",
    description:
      "Thrown when a payload validation predicate returns false.\n\n@remarks\nUse ``validatePayload`` guard to trigger this error.",
  },
  {
    name: "PayloadValidationError",
    kind: "type",
    description: "",
  },
  {
    name: "PersistenceConfig",
    kind: "interface",
    description: "",
  },
  {
    name: "pipe",
    kind: "function",
    description: "",
  },
  {
    name: "pluck",
    kind: "function",
    description:
      "Creates a function that plucks a property (or nested property) from an object.\n\n@returns\nA function that extracts the value at the path.\n\n@remarks\nReturns undefined if any part of the path is null/undefined.",
  },
  {
    name: "positiveNumber",
    kind: "function",
    description:
      "Type guard for positive numbers.\n\n@returns\nTrue if value is a positive number.",
  },
  {
    name: "Predicate",
    kind: "interface",
    description: "",
  },
  {
    name: "Refinement",
    kind: "interface",
    description: "",
  },
  {
    name: "RequiredPayloadError",
    kind: "const",
    description:
      "Thrown when a required payload is missing or null/undefined.\n\n@remarks\nUse ``fromPayload`` guard to trigger this error.",
  },
  {
    name: "RequiredPayloadError",
    kind: "type",
    description: "",
  },
  {
    name: "Result",
    kind: "type",
    description: "",
  },
  {
    name: "resultFlatMap",
    kind: "function",
    description: "",
  },
  {
    name: "resultFromNullable",
    kind: "function",
    description: "",
  },
  {
    name: "resultGetOrElse",
    kind: "function",
    description: "",
  },
  {
    name: "resultGetOrThrow",
    kind: "function",
    description: "",
  },
  {
    name: "resultMap",
    kind: "function",
    description: "",
  },
  {
    name: "resultMapError",
    kind: "function",
    description: "",
  },
  {
    name: "right",
    kind: "function",
    description: "",
  },
  {
    name: "Right",
    kind: "interface",
    description: "",
  },
  {
    name: "select",
    kind: "function",
    description:
      "Selects a property from an object.\n\n@returns\nThe property value, or undefined if not present.",
  },
  {
    name: "some",
    kind: "function",
    description: "",
  },
  {
    name: "Some",
    kind: "interface",
    description: "",
  },
  {
    name: "StateOf",
    kind: "type",
    description: "Extracts the state type from an Action or ActionCreator.",
  },
  {
    name: "StateTransitionError",
    kind: "const",
    description:
      "Thrown when a state transition produces an unexpected state tag in strict mode.\n\n@remarks\nOnly thrown when ``strict: true`` is set in store configuration.",
  },
  {
    name: "StateTransitionError",
    kind: "type",
    description: "",
  },
  {
    name: "StoreConfig",
    kind: "interface",
    description: "Configuration options for creating a TagixStore.",
  },
  {
    name: "SubscribeCallback",
    kind: "type",
    description: "Callback invoked on state changes.",
  },
  {
    name: "SubscribePathCallback",
    kind: "type",
    description: "Callback invoked when a specific path in state changes.",
  },
  {
    name: "taggedEnum",
    kind: "function",
    description: "",
  },
  {
    name: "TaggedEnum",
    kind: "type",
    description: "",
  },
  {
    name: "TaggedEnumConstructor",
    kind: "type",
    description: "",
  },
  {
    name: "TaggedError",
    kind: "function",
    description: "",
  },
  {
    name: "TaggedError",
    kind: "interface",
    description: "",
  },
  {
    name: "TaggedState",
    kind: "type",
    description: "",
  },
  {
    name: "TagixContext",
    kind: "class",
    description:
      "Context wrapper around TagixStore providing dependency injection, subcontexts, and hook patterns.\n\n@remarks\nManages subscriptions, child contexts, and provides dependency injection via ``provide`` method.",
  },
  {
    name: "TagixError",
    kind: "type",
    description:
      "Union type of all Tagix error instances.\n\n@remarks\nUse this for comprehensive error handling across the library.",
  },
  {
    name: "TagixErrorObject",
    kind: "interface",
    description:
      "Structured error object with tag, code, and message.\n\n@remarks\nAll Tagix errors conform to this shape for consistent error handling.",
  },
  {
    name: "TagixStore",
    kind: "class",
    description:
      "Core store implementation for Tagix state management.\n\n@remarks\nManages state transitions, subscriptions, and error tracking.",
  },
  {
    name: "tap",
    kind: "function",
    description: "",
  },
  {
    name: "TestError",
    kind: "const",
    description:
      "Test error for consistent error testing.\n\n@remarks\nUsed in test files for predictable error handling.",
  },
  {
    name: "TestError",
    kind: "type",
    description: "",
  },
  {
    name: "toResult",
    kind: "function",
    description: "",
  },
  {
    name: "toResultAsync",
    kind: "function",
    description: "",
  },
  {
    name: "tryCatch",
    kind: "function",
    description: "",
  },
  {
    name: "tryCatchAsync",
    kind: "function",
    description: "",
  },
  {
    name: "tuple",
    kind: "function",
    description: "",
  },
  {
    name: "UnexpectedStateError",
    kind: "const",
    description:
      "Thrown when state is in an unexpected condition.\n\n@remarks\nUse ``ensureState`` guard to trigger this error when state tag doesn't match.",
  },
  {
    name: "UnexpectedStateError",
    kind: "type",
    description: "",
  },
  {
    name: "unwrap",
    kind: "function",
    description: "",
  },
  {
    name: "updateState",
    kind: "function",
    description:
      'Creates a state updater that preserves variant-specific properties.\nUse this when updating properties that may not exist on all variants.\n\n@returns\nThe updated state.\n\n@example\n````ts\nconst increment = createAction<{ amount: number }, CounterState>("Increment")\n  .withPayload({ amount: 1 })\n  .withState((s, p) => updateState(s, {\n    value: getValue(s, "value", 0) + p.amount\n  }));\n````',
  },
  {
    name: "useDispatch",
    kind: "function",
    description:
      'Get a dispatch function to send actions through a context.\n\n@returns\nA function that sends actions.\n\n@example\n````ts\nconst dispatch = useDispatch(context);\ndispatch("Increment", { amount: 1 });\n````',
  },
  {
    name: "useGetState",
    kind: "function",
    description:
      'Get a type-safe way to read state properties by variant tag.\n\n@returns\nA function that takes a context and gives you a getter for state props.\n\n@example\n````ts\nconst getUserState = useGetState<UserStateType>();\nconst context = createContext(store);\n\n// IDE will suggest "LoggedOut" | "LoggedIn" for the tag\n// Then suggests "name" | "email" | "role" based on that tag\nconst name = getUserState(context)("LoggedIn", "name");\n\n// Or get the whole props object for a tag\nconst userProps = getUserState(context)("LoggedIn");\nif (userProps) {\n  console.log(userProps.name);\n  console.log(userProps.email);\n}\n````',
  },
  {
    name: "useGetStateRaw",
    kind: "function",
    description: "Internal helpers for state property access.",
  },
  {
    name: "useKey",
    kind: "function",
    description:
      'Read one specific property from state.\n\n@returns\nThe property value or undefined if it does not exist.\n\n@example\n````ts\nconst count = useKey(context, "value");\n````',
  },
  {
    name: "useSelector",
    kind: "function",
    description:
      'Extract a value from state using a selector function.\n\n@returns\nThe value from running the selector once.\n\n@example\n````ts\nconst userName = useSelector(context, (state) =>\n  state._tag === "LoggedIn" ? state.name : null\n);\n````',
  },
  {
    name: "useStore",
    kind: "function",
    description:
      "Get the current state from a context.\n\n@returns\nThe current state value.\n\n@example\n````ts\nconst state = useStore(context);\nconsole.log(state._tag);\n````",
  },
  {
    name: "useSubscribe",
    kind: "function",
    description:
      'Listen for state changes and run a callback each time.\n\n@returns\nA cleanup function to stop listening.\n\n@example\n````ts\nconst unsubscribe = useSubscribe(context, (state) => {\n  console.log("New state:", state);\n});\n````',
  },
  {
    name: "validatePayload",
    kind: "function",
    description:
      "Creates a payload validator that throws if validation fails.\n\n@returns\nA function that throws ``PayloadValidationError`` if predicate returns false.",
  },
  {
    name: "when",
    kind: "function",
    description:
      "Creates a type guard that narrows state to a specific tag.\n\n@returns\nA refinement function that narrows the state type.",
  },
  {
    name: "withState",
    kind: "function",
    description:
      "Executes a function with state if it matches the specified tag.\n\n@returns\nThe function result, or undefined if tag doesn't match.",
  },
];
